# Layer System for Chart Composition

## Overview

Implement a fluent layer API for `ChartBuilder` that works like let-bindings, allowing layers to reference and query previous layers' data and nodes. This enables building complex charts (ribbons, area charts) by connecting elements across layers.

## Core Design

### 1. Layer Structure

Each layer will return a `LayerRef<T>` containing:

- `node: GoFishNode` - the rendered graphics
- `data: T` - the original data or grouped data structure
- `nodes: Map<string, GoFishNode>` - keyed nodes for lookup (populated from `.name()` calls during rendering)

### 2. API Pattern

```typescript
chart(seafood)
  .layer('bars', (data) =>
    flow(data,
      spread_by('lake', { dir: 'x' }),
      derive()
      stack_by('species', { dir: 'y' }),
      rect({ h: 'count', fill: 'species' })
    )
  )
  .layer('ribbons', (data, layers) =>
    // Access previous layer and query it
    flow(
      data,
      group_by('species'),
      connect({ dir: 'x', opacity: 0.8 }),
      ref(bars.lake.species) /* maybe a keys -> shapes data structure generated by operators and stuff */
    )
    /* or maybe... */
    flow(
      bars, /* maybe a keys -> shapes data structure generated by operators and stuff */
      // but if it's structured then why would I group_by?
      /* THIS WON'T WORK B/C EG YOU MAY WANT A DATASET THAT  */
      group_by('species'),
      connect({ dir: 'x', opacity: 0.8 }),
      // ref(),
    )
  )
  .render()
```

### 3. Data Querying

Support queries like:

- `layers.bars.nodes` - all nodes in the bars layer
- `layers.bars.data` - the data used to create bars
- `layers.bars.select('lake', 'lake1')` - filter nodes by grouping key
- `layers.bars.groupBy('species')` - re-group nodes by different key

## Implementation Steps

### Phase 1: Core Layer Infrastructure

**File**: `src/ast/marks/chart-forward-v2.ts`

1. Add `LayerRef<T>` type:

```typescript
export interface LayerRef<T = unknown> {
  node: GoFishNode;
  data: T;
  nodes: Map<string, GoFishNode>;
  select(key: string, value: any): GoFishNode[];
  filter(predicate: (item: any) => boolean): GoFishNode[];
}
```

2. Update `ChartBuilder` to track layers:

```typescript
export class ChartBuilder<T> {
  private readonly data: T;
  private layers: Map<string, LayerRef<any>> = new Map();

  layer<U>(
    name: string,
    fn: (data: T, layers: Record<string, LayerRef<any>>) => GoFishNode
  ): ChartBuilder<T>;

  render(): GoFishNode;
}
```

3. Implement `createLayerRef` helper to build LayerRef from a GoFishNode by:
   - Walking the node tree
   - Collecting all named/keyed nodes into the `nodes` Map
   - Attaching query methods

### Phase 2: Connect Operators

**File**: `src/ast/marks/chart-forward-v2.ts`

Add operators for connecting across layers:

1. `connectAcross(layer, groupKey, options)` - connect elements with the same group key value across a spatial dimension
   - Uses the existing `connect`/`connectX`/`connectY` from `src/ast/graphicalOperators/`
   - Groups nodes by data key, creates refs to connect them

2. Helper to extract node-to-data mappings from LayerRef for querying

### Phase 3: Enhanced spread_by

Update `spread_by` to store grouping metadata in the returned node structure so that LayerRef can reconstruct groupings.

### Phase 4: Integration & Examples

1. Update the example at the bottom of `chart-forward-v2.ts`
2. Create a ribbon chart example showing layer composition
3. Add tests/stories demonstrating the API

## Key Files

- `src/ast/marks/chart-forward-v2.ts` - main implementation
- `src/ast/graphicalOperators/connect.tsx` - reuse for connecting
- `src/ast/_node.ts` - reference for node structure
- `src/ast/_ref.tsx` - reference for ref/lookup pattern

## Notes

- Leverage existing `name()` and `setKey()` on GoFishNode for node tracking
- Use existing `ref()` function pattern from the codebase for node references
- The layer system builds on top of the existing flow/operator pattern
- Each layer is independent but can query previous layers through the `layers` parameter
